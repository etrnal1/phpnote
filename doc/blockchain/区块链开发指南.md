## 区块链项目开发指南

### 序言

如何学习以太坊？ -> 从以太坊的白皮书和黄皮书开始/Building Blockchain Projects

通过有趣的现实世界案例，将了解到如何编写完全按照程序运行、没有欺诈、没有中心机构或者第三方干预的智能合约，并学习如何创建端到端的区块链应用。

将介绍加密货币中的密码学、以太币安全、挖矿、智能合约和Solidity等概念

实例代码下载地址：http://www.packtpub.com

​				http://www.hzbook.com

### 第一章 去中心化应用

##### 1.1 什么是Dapp

目前几乎所有互联网应用都是中心化，每个应用的服务端由一个特定的企业或者个人所有，开发者在开发中心化应用，用户也一直在使用中心化应用。

但是中心化应用存在一些问题：不透明、单点故障、不能防止网络审查。几乎不可能创建某些特定类型的应用

为了解决这一问题，去中心化应用诞生了，它创建以网络为基础的去中心化应用Dapp

Dapp是一种互联网应用，其后端在去中心化的点对点的网络上运行，且源代码是开源的，网络中不存在能够完全控制的Dapp节点

不同的Dapp使用不同的数据接口来存储应用数据，比特币Dapp使用区块链数据接口

- 一致性协议。Dapp中没有一个中心服务器来协调节点或者决定什么是对的什么是错的，一致性协议可用于解决这个问题（concensus protocol），不同的Dapp通常使用不同额数据结构类型的共识协议，比特币使用   **工作量证明协议（PoW**来达成共识

为了让用户使用Dapp，每个Dapp都需要一个客户端，使用时，用户首先要运行Dapp中自己的节点服务端，然后将客户端连接至节点服务器。

Dapp的节点只是提供API，并允许开发者社区使用API开发多种客户端

建立客户端架构比较麻烦，因此客户端通常作为服务或节点形式出现

- Dapp的优点
  - Dapp能容错，没有单点故障，默认分布式
  - 防止某单一机构的干扰
  - 用户容易相信该应用

- Dapp的缺点
  - 修改bug或者更新Dapp很困男，因为网络中每一个节点都需要更新其节点软件
  - 一些应用要求验证用户身份（KYC），却没有中心化的机构来验证用户身份，开发时会遇到问题
  - 创建去中心化应用比较困难，因为他们应用复杂的协议达成共识，并且必须从最開是就自行创建并扩大规模，所以不能仅仅实现一个想法，然后不断添加功能
  - 应用通常独立于第三方API，以获取或者存储数据。Dapp不能依赖中心化应用的API，但是可以依赖其他Dapp，目前Dapp生态圈不大，所以创建起来比较困难，在实践中紧密融合Dapp也比较困难

##### 1.2 去中心化自治组织

Decentralized Autononmous Organization (DAO) 由计算机程序代表的组织（即组织根据程序中写明的规则运行），完全透明、完全由股东控制，不受政府影响。

为了达到这个目标，需要把DAO作为DApp来开发，可以说DAO是Dapp的一个子类

##### 1.3 Dapp中的用户身份

Dapp主要优点是它一般能保证用户的匿名性，但是许多应用要求用户必须经过身份验证才能使用，因为Dapp没有中央机构，验证身份是一项挑战

KYC Know Your Customer

Dapp不能理解和验证扫描文档，也不能发送短信，因此需要用户提供哪些他们可以理解和验证的数字标识，问题是几乎没有Dapp有数字标识，用户也不知道如何得到数字身份

数字身份有多种形式，目前最受推崇最热门的形式是数字证书（一个用来证明公钥所有权的电子文档）

基本上一个用户拥有私钥、公钥和数字证书

数字证书由用户可以信任的授权机构颁发

目前可供选择的方案：由提供客户端的公司派人手动验证用户身份，比如创建一个比特币账户不需要验证身份，但是当提现的时候交易所去验证

在应用中验证身份的想法是使一些用户在进行一些欺诈行为之后难以逃脱，让用户难以伪装成其他人，并收集足够的数据跟踪用户，证明该用户进行了一些欺诈行为

##### 1.4 Dapp中的用户账户

有多种实现方式，现在最热门的是公钥-私钥来代表一个账户。公钥的哈希是账户的唯一身份，为了改变账户中的数据，用户需要私钥签名

##### 1.5 访问中心化应用

Dapp不能依赖于中心化应用，原因是存在单点故障，但是在一些情况下Dapp需要从中心化应用中抓取数据，但是主要问题是Dapp如何知道一个域名中抓取的数据有没有被中间人篡改，数据是否还是真实的响应。

根据Dapp架构的不同，解决办法也有所不同，在以太坊中，智能合约不能直接发出HTTP请求，为了访问中心化API，可以使用Oraclize服务作为中间人，Oraclize为从中心化服务智能合约中的数据提供TLSNotart验证

#### 1.6 Dapp中的内部货币
中心化应用的所有者需要有盈利才能长期维护应用的运行，Dapp虽然没有所有者，但是和中心化应用一样，Dapp节点需要硬件和网路资源才能维持运行。

Dapp节点需要一些有用的回报来维持运行，于是内部货币登场了，大多数Dapp都有内置内部货币。

共识协议决定节点收取多少的内部货币。

根据共识协议，只有为维护Dapp安全和运行做出贡献的哪些特定节点可以赚取货币，只进行数据读取的节点没有回报，也就是指挖矿。

- Dapp内部货币的缺点

Dapp不能再免费使用了，免费是中心化应用占上风的原因之，因为中心化应用可以通过广告赚钱，为第三方应用提供优质API，所以可以对用户免费。在Dapp中不能加入广告，因为没有人去检查广告尺度，客户端还可能不展示广告，因为展示广告对他们没有好处。

##### 1.7 什么是授权Dapp

授权的Dapp并不对所有人开放。授权的Dapp继承了面权限Dapp的全部属性，但是需要权限才能参与到网络中去。授权的Dppp与免权限的Dapp的共识协议是不同的，授权的Dapp没有内部货币。
##### 1.8 热门的Dapp
- 比特币

**账本：** 本质上是一个交易列表。数据库与账本不同，在账本中我们只能添加新的交易；在数据库中我们可以CURD，数据库可以用来实现账本。
**区块链：** 是用于创建区中心化账本的数据结构，区块链中的区块按序号排列。区块包含一系列的交易、前一个区块的哈希、时间戳、区块回报、区块序号等。

每一个区块包含前一个区块的哈希，由此创建了区块彼此相连的链，网络中的每一个节点都保留区块链的一个备份

**工作量证明和权益证明等是用于保障区块链安全性的多种共识协议**

在工作量证明中，通过挖矿创建区块，这让区块链保持安全。
在工作量证明协议中，挖矿涉及解决复杂问题。

**为什么使用比特币：可以在世界上任何地方快速便捷地发送和接收支付、比特币交易费低于在线支付交易费。黑客可以从商户哪里窃取支付信息，但是在比特币情况下，窃取了比特币的地址是完全没用的，必须使用相关私钥签名**

- 以太坊
是一个去中心化平台，可以在其上运行使用智能合约编写的Dapp
以太坊智能合约完全按照程序运行，杜绝了停机、去中心化操控、欺诈和第三方能干涉的可能性。
使用以太坊运行智能合约的主要优点是方面智能合约彼此交互，而且不需要担心整合共识协议等事情，只需编写应用所需逻辑即可。

以太坊有一种内部货币叫做以太币ether，部署只能合约或者执行只能合约函数需要用到以太币。

- 超级账本

超级账本项目致力于开发创建授权的Dapp技术，Hyperledger fabric是Hyperledger项目的一个实现。

fabric是一个区中心化的授权平台，它允许在其上运行授权的Dapp。fabric是即插即用系统，可以方便地即插即用多种公式协议和功能。

- IPFS

星际文件存储系统是一个去中心化的文件系统。使用分布式哈希表和Merkle有向无环图数据结构。它使用类似于BitTorrent比特流的协议来决定如何在网络中移动数据。

在文件系统中，所存储的内筒会一直保留到被删除之前每一个节点并不存储全部文件，存储的是需要的文件。

如果一个文件不那么受欢迎，许多节点就没有这个文件，那么该文件很有可能从网络中消失。

- Namecoin

Namecoin是一个去中心化的键值数据库，它的内部货币叫做域名币。使用区块链数据结构和工作量证明共识协议。

- 达世币

达世币是一种类似于比特币的去中心化货币，使用区块链数据结构和工作量证明共识协议，并解决了比特币面临的一些主要问题。

- BigChainDB

允许用户部署自己的、授权的或者免权限去中心化数据库，使用区块链数据结构以及其他多种特定数据库数据结构。

- OpenBazaar

是一个去中心化的电子商务平台，可以在其上买卖物品，用户不是匿名的，因为IP被记录了，节点可以是买方、卖方或者中间人。

使用Kademlia分布式哈希表数据结构。

- Ripple

瑞波是一个去中心化的转账平台，允许兑换货币、数字货币和大宗商品。使用区块链数据结构，并且有自己的共识协议。在Ripple相关文档中，找不到区块、区块链等词汇，用账本来代替。

瑞波币不是由挖矿生成的，最初就有1000亿个瑞波币，最初由Ripple公司拥有，是手动供给的。
##### 1.9 总结

### 以太坊的工作原理

##### 2.1 以太坊概览

以太坊是一个去中心化的平台，可以在其上部署Dapp，Dapp用一个或者更多个只能合约创建，使用Solidity编程语言编写只能合约。智能合约完全按照程序运行，而且防停机、防审查、防欺诈、防第三方干扰。

以太坊的内部货币为以太坊，部署智能合约或者调用其方法需要用到以太币。只能合约可以有多个实例，每个实例都有自己专门的地址，用户账户和智能合约都可以持有以太币。

以太坊使用区块链数据结构和工作量证明共识协议。

有两种网络中的节点：普通节点和矿工，普通节点只备份区块链上的数据，而矿工通过挖矿创建区块链。

##### 2.2 以太坊账户

创建以太坊账户，只需要一个非对称加密密钥对 - 由不同算法生成，如RSA、ECC

以太坊使用ECC 椭圆曲线加密算法，它拥有多个参数来调节速度和安全性，以太坊使用secp256k1参数。

以太坊使用256位加密，公钥是一个256位数，被编译成长度为64的十六进制字符串

从公钥生成地址的过程如下：

    - 生成公钥的keccak-256哈希，给出一个256位数字
    - 丢弃前面的96位，即12个字节，得到160位二进制数据，20字节
    - 把地址编译成十六进制字符串，得到一个40字符串的字节串，就是账户地址

##### 2.3 交易

交易是一个签名数据包，用于从一个账户向另一个账户或者向一个合约转以太币、调用合约方法或者部署一个新合约。

交易使用椭圆曲线数字签名算法（ECDSA）签名、ECDSA是一种基于ECC的数字签名算法。

交易包含：
   
    -   信息接受者
    -   识别发起人及其意愿的签名
    -   要转账的以太币数量
    -   交易执行允许进行的计算资源最大值(gas上线)
    -   交易发起人愿意为单位计算资源支付的费用（gas价格）
    -   输入数据（如果调用合约方法）
    -   初始化代码（如果目的是部署合约）
    
**交易费=交易消耗的gas * gas价格**

如果确定交易将永久出现在区块链中，则称交易已确认。
##### 2.4 共识

以太坊使用工作量证明共识协议防止区块链被篡改。工作量证明系统需要解决一个复杂问题以创建一个新的区块。

**在工作量证明系统中，创建区块的过程称为挖矿，旷工是网络中挖区块的节点。**

网络安全不是用矿工总数衡量，而是用网络中的全部算力衡量。

区块链中有多少个区块没有限制，可以生成的以太币总数也没有限制。

为了挖区块，旷工首先从收到的广播中收集新的、未挖处处的交易，然后过滤掉不合法的交易。

***合法的交易必须满足正确的使用私钥签名、账户中有足够的余额进行交易等条件***

现在矿工创建一个有区块头和内容的区块，内容是区块包含的交易列表。

区块头包含前一个区块的哈希、区块序号、随机数、目标值、难度值、矿工地址等内容。

- 时间戳表示区块初始时间
- 随机数是一个没有意义的值，纯粹是为了设置一个小于或等于目标值的区块哈希，以太坊使用ethash哈希算法，发现随机数的唯一方法是穷尽所有可能，目标值是一个256位的数字，根据不同的因素计算。

区块头的难度值是目标值的一种不同表述方法，目标值越低，发现随机数需要的时间越多。目标值越高需要的时间越少。

计算问题难度值的公式如下：
```
current_block_difficulty = previous_block_difficulty + previous_block_difficulty // 2048 * max(1 - (currency_block_timestamp - previous_block_timestamp) // 10, -99) + int(2 ** ((current_block_number // 1000) -  2))
```

如果网络中的节点接收到两个不同的合法区块链，那么多有取款的整体难度值较高的那个区块链被视为合法的区块链。
##### 2.5 时间戳

计算区块目标值的公式需要用到当前时间戳，且每个区块在区块头附加了当前时间戳。

没有什么机制可以阻止矿工在挖区块时使用其他时间戳(而非当前时间戳)。
时间戳验证失败，其他节点不会接受该区块，这样就浪费了矿工的资源。

当一个矿工广播一个新挖出的区块时，其他节点对其时间戳的验证取决于其时间戳是否大于前一个区块的时间戳。
##### 2.6 随机数

随机数是一个64位未签名证书。随机数是一个问题的解决办法，矿工不断尝试随机数，知道发现目标值。

每个矿工挖的区块的哈希是不同的，因为哈希取决于如时间戳、旷工地址等内容，而且对于所有狂公共来说这些内容很可能是不一样的。因此解决问题并不是一场比赛，而更像是意见碰运气的事
##### 2.7 区块时间

我们看到的区块难度值公式使用了一个长达10s的阈值以确保挖出父区块和子区块的时间差在10~20s因为我们需要有一个相对稳定的生成区块的平均时间，即区块时间。

无效区块：两个矿工同时挖出了一个区块，网络最终会接受难度值较大的那个区块，被放弃的那个区块就是无效区块。

网络中生成的无效块总数与生成新的区块所需的平均时间成反比。难度越简单，区块时间越短，就有可能有更多的矿工挖出矿工，最终会舍弃很多区块。

无效块会影响区块链的安全，网络安全由网络中矿工的全部算力衡量，当算力增加时难度值也要增加，以确保区块不是在平均时间之前生成的

更高的难度值意味着更安全的区块链，因为篡改所需的算力会比多，而且最后不会被接受

**以太坊用ghost协议解决无效块带来的安全问题。**
ghost协议仅仅把无效块添加到母链上，掩盖了安全问题，由此增加了区块链的整体难度值（包括无效块的难度值之和）。

如何在不产生交易冲突的情况下把无效块添加到母链中呢？
事实上，任何一个区块链都可以接纳零个或者多个无效块

为了激励矿工接纳无效块，矿工接纳无效块也会得到回报，无效块中的交易不需要确认，无效块矿工也不想无效块接纳的交易收取交易费

在以太坊中 无效块称为 **叔块**

**矿工接纳无效块得到的回报计算公式为**`(uncle_block_number+8-block_number) * 5 / 8`

其余回报归侄块即包含孤块的区块。
##### 2.8 分叉

在节点验证区块链发生冲突时，会发生分叉 forking

分叉分为三种：
- 普通分叉
> 由于两个或者多个矿工几乎同时发现了一个区块引起的暂时冲突，如果一个区块的难度高于另一个，这个冲突就解决了。
- 软分叉
> 更改源代码，要求有50%以上算力的矿工升级。例如：更新源代码使得旧区块/交易的一部分失效，有50%以上算力矿工升级后可以解决，这样新的额区块链将有更大的难度值，最后被整个网络接受
- 硬分叉
> 更改源代码引起冲突，全部矿工升级，以解决冲突。例如更改源代码为了个更改对矿工的汇报，全部矿工都需要升级。
##### 2.9 创世区块

genesis block，区块链中的第一个区块，其区块序号是0。

只有网络中的两个节点有相同的创世区块，他们才会彼此配对进行同步，否则他们将会彼此拒绝。
每一个节点生成自己的创世区块
对于不同的网络，创世区块被硬编到客户端里
##### 2.10 以太币面值

```
1以太币 = 1000000000000000000 wei（18个0 100万千亿）

        = 1000000000000000    Kwei

        = 1000000000000       Mwei

        = 1000000000          Gwei

        = 1000000             Szabo

        = 1000                Finnery

        = 0.01                Kether
```
##### 2.11 以太坊虚拟机

以太坊虚拟机是以太坊只能合约字节码执行环境，网络中的每个节点都运行EVM，所有节点执行使用EVM指向智能合约的全部交易，因此他们进行同样的计算，并存储同样的数值

出于各种原因，每个节点执行并存储最终状态。

有两种EVM实现
- 字节码VM
- JIT-VM
在两种情况下Solidity代码被编译成字节码，在JIT-VN中，字节码编译更充分，比字节码VM更高效

##### 2.12 gas

计算资源的计量单位。

每个交易包含gas上限和为每个gas支付费用的单价
##### 2.13 发现对等节点

节点不需要连接到网络中的每一个节点，它只连接到几个其他节点，这些节点再连接到另外一个节点，按照这个方式，整个网络彼此连接。

以太坊有自己的节点发现协议可用于解决发现网络中的其他节点。该协议以Kadelima协议为基础。

在节点发现协议中有一个特殊节点，叫做**Bootstrap节点**，它保存了一段时间内与他们连接的所有的节点的列表，但其本身不保存区块链。

当对等节点连接到以太坊网络时，他们首先连接到BootStrap节点，然后由它连接到他们的对等节点列表，然后对等节点与对等节点连接并同步。

以太坊网络有两种
- 主网
> 用于交易
- 测试网络
> 供开发人员测试
##### 2.14 Whisper和Swarm

Whisper和Swarm分别是去中心化的通信协议和存储平台，由以太坊开发人员开发。

- Whisper：去中心化的通信协议 https://github.com/ethereum/wiki/wili/Whisper
> 允许网络中的节点彼此通信，支持广播、用户到用户、加密信息等，但不用于传输数据
- Swarm：去中心化的文件系统 https://github.com/ethersphere/go-ethereum/wiki/IPFS-&-SWARM
> 类似于Filecoin，最大的区别是技术细节和激励机制。Filecoin不惩罚存储，Swarm惩罚存储，进一步提高的文件的可用性

仍在开发中
##### 2.15 geth

是以太坊、Whisper和Swarm节点的一个实现，可以成为全部实现或者一些选定实现的一部分，合并他们的目的是让他们看起来想一个单一的Dapp，通过一个节点客户端可以访问三个dapp

geth是一种CLI应用，使用Go语言编写，在主要的操作系统中都可以使用。

###### 2.15.1 安装
```
brew tap ethereum/erhereum
brew install geth

#ubuntu
sudo apt-get install software-properties-commin
sudo add-apt-repository -y ppa:etherum/ethereum
sudo apt-get update
sudo apt-get install ethereum
```

##### 2.15.2 JSON-RPC和JavaScript操作台
https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console
geth为其他应用提供了与其通信的JSON-RPC API geth使用HTTP、WebSocket和其他协议服务于JSON-RPC API

JSON-RPC API分为：
- admin
- debug
- eth
- miner
- net
- personal
- shh
- txpool
- web3
等类型

###### 2.15.3 子命令和选项
- 连接至主网络
```
geth --datadir '/usr/mnt/eth' --networkid 1

//--datadir 指定在哪里存储区块链默认路径[$HOME/.ethereum]
//--networkid 指定网络ID 1代表主网络 2代表测试网络，默认为1
```
- 创建私有网络

只需要给出一个随机网络ID即可。通常创建私有网络的目的是进行开发，可以简单使用--dev 标记运行一个私有网络

###### 2.15.4 创建账户

```
//创建新账户
geth account new
//获取用户所有列表,秘钥默认存储在--datadir路径中，可以使用--keystore选项指定一个不同的目录
geth account list
```
- 挖矿

默认geth不启动挖矿，提供--mine选项就可以进行挖矿，还有一些其他的参数

```
--mine 开始挖矿
--minerthreads 执行哈希过程中使用的线程总数，默认使用8个线程
--etherbase 挖矿赚取的回报存入的地址
#账户默认是加密的，所以要访问账户中的以太币，需要解锁。
--unlock 解锁一个或者多个账户，使用逗号分隔地址可以提供多个地址

geth --mine --minerthreads 16 --etherbase '5415b18cd4802c5bc3ab0c28a40c2f840623a956' --unlock '5415b18cd4802c5bc3ab0c28a40c2f840623a956'
```

- 快速同步

不下载整个区块，只下载区块头、交易凭证和最新的状态数据库。

为了检查区块链的真实性，该算法在每一个已定义的区块序号之后下载一个完整的区块
快速同步算法 https://github.com/ethereum/go-ethereum/pull/1889

在运行geth过程中使用--fast即可
fast sync只在初始同步时运行，在节点成功与网络同步之后，fast sync就永远禁用了

##### 2.16 以太坊钱包
以太坊钱包使用IPC与geth通信，geth支持以文件为基础的IPC
##### 2.17 浏览器钱包

浏览器钱包Mist是以太坊、Whisper和Swarm的一个客户端，允许用户发送交易、发送Whisper信息、检查区块链等
##### 2.18 以太坊的缺点
- Sybil攻击
> 攻击者视图用它控制的普通节点占满整个网络，用户很有可能只连接到攻击者节点，一旦连接到攻击值节点，攻击者可以拒绝所有节点转播区块和交易，从而将用户网络中断开，攻击者只能转播他创建的区块，从而会将用户放到分开的网络上。

- 51%攻击
> 如果攻击者掌握了网络中一半以上的算力，他就可以比网络中的其他人更快生成区块，可以保留它的私有分叉，知道分叉比诚实网络创造的更长，然后广播自己的分叉
还可以重写交易，阻止一些交易被挖出，并阻止其他矿工挖出的区块被添加到区块链中。
##### 2.19 serenity

以太坊下一个主要更新的名字。这个更新将要求硬分叉，把共识协议改为casper，并将整合状态通道和分片。
##### 2.20 总结

### 第三章 编写智能合约

将使用Solidity编程语言创建一个Dapp用于证明在特定时间的存在、真实性和所有权，即证明一个文件在一个特定时间属于一个特定所有者
- Solidity源文件布局
- 理解Solidity的数据类型
- 合约的特殊变量和函数
- 控制结构
- 合约的结构和功能
- 编译和部署智能合约

##### 3.1 Solidity 源文件

Solidity源文件使用的扩展名为.sol
MacOS部署Solidity

http://wiki.jikexueyuan.com/project/solidity-zh/installing-solidity.html
##### 3.2 智能合约的结构

合约就像一个类，其中包含：状态变量、函数、函数修改器、事件、结构、枚举

合约还支持继承，通过在编译时备份代码来实现

合约同样支持多态

```
//contract关键字声明一个合约
contract Sample {
    //静态变量
    uint 256 data;//声明data，包含一些数据
    adddress owner;//声明owner 包含所有者的以太坊地址
    
    //定义一个事件，用来通知客户端，一旦data变化，将触发这个事件
    event logData(uint256 dataToLog);
    
    //函数修改器，用于在执行一个函数之前自动检测条件
    modifier onlyOwner() {
        if (msg.sender != owner) throw;
        _;
    }
    
    //construtor得到合约构造函数，在部署合约时，调用构造函数。用于初始化状态变量
    function Sample(uint256 initData, address initOwner)
    {
        data = initData;
        owner = initOwner;
    }
    
    //函数
    function getData() returns (uint256 returnedData) {
        return data;
    }
    
    function setData(uint256 newData) onlyOwner {
        logData(newData);
        data = newData;
    }
}
```

##### 3.3 数据位置

在Solidity中，根据情况的不同，变量可能不存储在内存和文件系统中。

对于复杂数据类型，例如字符串、数组和结构类型struct可以向类型中添加storage或者memory进行重写。

函数参数默认使用memory

本地变量默认使用storage

状态变量位置强制使用storage

数据位置很重要，因为他们会改变分配的行为：
- storage变量和memory变量之间的分配总是创建一个独立的备份。但是如果分配是从memory存储的一种复杂类型到另一种复杂类型，则不创建备份
- 到一个状态变量的分配总是创建一个独立的备份
- 不能把memeory中存储的复杂类型分配给本地存储变量
- 在分配状态变量给本地存储比阿尼量的情况下，本地存储变量指向状态变量，本地存储变量变为指针。

##### 3.4 什么是不同的数据类型

Solidity是一种静态类型语言，变量存储的数据类型需要预先定义，所有变量默认值都是0

- 布尔值
> 最简单的数据类型，可以是true或者false
- uint8,uint16,uint36...uint256分别用于存储无符号8、16、36位整数，同样还有int8,int16,int36...
- ufixed和fixed代表分数，ufixed0x8,yfixed0x16用于存储未签名的8位、16位分数
- address 用于存储最大20字节的值（16进制表示）用于存储以太坊地址
> address类型有两个属性balance和send。balance用于检测地址余额，send用于向地址发送以太币。send方法拿出需要转账数量的wei，并根据转账是否成功返回true或者false

###### 3.4.1 数组类型
Solidity支持generic和byte两种数组类型，他们支持固定长度和动态长度两种数组，也支持多为数组

-    generic数组类型
```
contract sample {
    //动态长度数组
    int[] myArray = [0, 0];
    function sample(uint index, int value) 
    {
        myArray[index] = value;
        
        int[] myArray2 = myArray;
        
        //固定长度数组
        uint24[3] memory myArray3 = [1, 2, 9999];
        
        uint8[2] myArray4 = [1, 2];
    }
}
```

-   数组有length属性，用户可以给length属性分型一个值，改变数组大小，但不可以在内存中改变数组大小，也不可以改变非动态数组大小
-   如果想分文动态数组的未设置索引，会抛出异常
-   array,structs和map都不可以用作函数参数，也不可以用作函数返回值

###### 3.4.2 字符串类型
在Solidity中，有两种方法创建字符串：使用bytes和string，byte用于创建原始字符串，string用于创建UTF-8字符串，字符串长度总是动态的

```
contract sample {
    string myString = "";
    bytes myRawString;
    
    function sample(string initString, bytes rawStringInit)
    {
        myString = initString;
        string myString2 = myString;
        
        //myString3存储在内存中
        string memory myString3 = "ABCDR";
        myString3 = 'sdsds';//改变myString3的值
        
        myRawString = rawStringInit;
        myRawString.length++;
        
    }
}
```
###### 3.4.3 结构类型
Solidity还支持结构类型
```
contract sample {
    struct myStruct {
        bool myBool;
        string myString;
    }
    myStruct s1;
    myStruct s2 = myStruct(true, "");
    
    function sample(bool initBool, string initString)
    {
        s1 = myStruct(initBool, initString);
        myStruct memory = myStruct(initBool, initString);
    }
}
```

###### 3.4.4 枚举类型

```
contract sample {
    enum OS {windows, Linux, OSX, UNIX}
    OS choice;
    
    function sample(OS chosen)
    {
        choice = chosen;
    }
    
    function setLinuxOS()
    {
        choice = OS.Linux;
    }
    
    function getChoice() returns (OS chosenOS)
    {
        return choice;
    }
}
```

###### 3.4.5 mapping类型
mapping数据类型还是一个哈希表。只可以存在storage中，不存在memory中，因为他们是作为状态变量声明的。

可以认为mapping类型包含key/value对，不是实际存储key，而是存储key的keccak256哈希，用于查询value。

mapping类型没有长度，不可以分配给另个一个mapping

```
contrcat sample {
    mapping (int => string) myMap;
    function sample(int key, string value)
    {
        myMap[key] = value;
        
        mapping (int => string) myMap2 = myMap;//myMap2是myMap的映射
    }
}
如果想访问mapping不存在的key，返回的value为0
```
###### 3.4.6 delete操作符
delete操作符可以用于任何变量，将其设置为默认值0；

如果对动态数组使用delete操作符，则删除所有元素，长度变为0

如果对于静态数组使用，则充值所有索引

对mapping类型使用，不发生任何作用，如果对mao的一个键使用，则会删除该键的值

```
function reset()
{
    delete myArray;
}
```
##### 3.5 控制结构

##### 3.6 用new操作符创建合约

##### 3.7 异常

##### 3.8 外部函数调用

##### 3.9 合约功能

##### 3.10 库

##### 3.11 返回多值

##### 3.12 导入其他Solidity源文件

##### 3.13 全局可用变量

##### 3.14 以太币单位

##### 3.15 存在、真实性和所有权合约

##### 3.16 编译和部署合约

##### 3.17 总结

