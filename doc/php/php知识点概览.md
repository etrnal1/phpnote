PHP框架

谈谈对MVC工作原理的认识和常见的MVC框架

Model、View、Controller

数据模型层，视图层、控制器(业务处理层)

TP、Yii2、CI、Yaf

单一入口工作原理

用一个处理程序文件处理多有的HTTP请求，根据请求参数的模块去完成对应操作

优势:

- 可以进行统一的安全性的检查
- 集中处理程序

劣势:

- URL不美观
- 处理效率会稍低

模板引擎的理解

	PHP 是一种HTML内嵌的在服务器端执行的脚本语言，但是PHP有很多可以使PHP代码和HTML代码分开的模板引擎，例如Smarty，Twig，Haml

工作原理： 庞大的完善的正则表达式的替换库

常见框架的特性考点

	php框架有哪些，用过哪些，各自的优缺点是什么？

	PHP框架的差异和优缺点

Yaf框架

使用php扩展的形式写的一个php矿建，以C语言为底层编写的，性能上要比PHP代码写的快一个数量级

优点：执行效率高，轻量级、扩展性高

缺点：高版本兼容性查、底层代码可读性差、需要安装扩展、功能单一、开发需要编写大量的插件

Yii2框架

Yii2框架是一款非常优秀的通用web后端框架，结构简单优雅，使用功能丰富，扩展性强，性能高

缺点： 学习成本高，量级重

常见框架的特性

Yii2的路由配置

Linux常用命令

系统安全：sudo,su,chmod ,setfacl

进程管理:w,top,ps,kill,pkill,killall，pstree

用户管理：id,usermod,useradd,groupadd,userdel

文件系统：mount,umount,fsck,df,du

系统关机和重启：shundown,reboot

网络应用:curl,telnet,mail,elinks

网络测试:ping,netstat,host

网络配置:hostname,ifconfig

常用工具:ssh,screen,clear,who,date

软件包管理：yum,apt-get,rpm

文件查找和比较:locate,find

文件内容查看:head,tail,less,more

文件处理:touch,unlink,rename,ln,cat

目录操作:cd,mv,rm,pwd,tree,cp,ls

文件权限属性：setfacl,chmod,chown,chgrp

文件传输:ftp,scp

压缩/解压：zip

系统定时任务

crontab命令:

crontab -e创建

*命令（分时日月周）

at命令:

一次执行

#at 2:00 tomorrow

at>/Home/Json/do_job at>Crtl+d

vim/vi 编辑器

一般模式:删除、复制、粘贴

切换编辑模式:i,I,o,O,a,A,r,R

切换命令模式:,/,?

移动光标:ctrl + f,crtl + b,0 home,$ end,G，gg,N +enter

查找替换:/word,?word,

:n1,n2s/word1/word2/g

删除复制粘贴:x,X、dd、ndd、yy、nyy、p、P、crtl+r,.

保存退出：wq

配置:

setnu,setnonu

shell

赋予权限，直接执行

chmod + x test.sh

source 命令

编写基础：

    #!/bin/sh
    #指定脚本解释器
    ...
    ...
    #编写具体功能

Mysql

Mysql基础操作

连接和关闭:mysql -u用户名 -p密码 -h主机地址 -P端口号

其他:\G,\c,\q,\s,\h,\d

InnoDB 表引擎

- 默认事务型引擎，最重要最广泛的存储引擎
- 数据存储到共享表空间，可以通过配置分开
- 对主键查询的性能高于其他类型的存储引擎
- 内部做了很多的优化，从磁盘读取数据时自动创建哈希索引
- 通过一些机制和功能支持真正的热备份
- 支持崩溃后的安全回复
- 支持行级锁
- 支持外键

MyISAM表引擎

- 拥有全文索引、压缩、空间函数
- 不支持事务和行级锁，不支持崩溃后的安全回复
- 表存储在两个文件 MYD和MYI
- 设计简单，某些场景下性能很好

其他表引擎 Archive、Blackhole、CSV

Mysql锁机制

基础概念： 表锁是日常开发中年常见的问题，因此是面试中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制问题

分为共享锁和排他锁

读锁

共享的，不堵塞，多个用户可以同时读取一个资源，互不干扰

写锁

排他的，一个写锁会阻塞其他的写锁和读锁，这样可以只允许一个人进行写入，防止其他用户进行的操作

锁粒度

表锁，系统性能开销最小，会锁定整张表，MyISAM

行锁，最大程度的支持并发处理，但是也带来了最大的锁开销InnoDB

事务处理

服务器层不管事务管理，由下层的引擎实现，所以一个事务中，使用多种存储引擎不靠谱

在非事务的表上执行事务操作Mysql不会提醒不会报错

存储过程

为以后的使用而保存的一条或者多条mysql语句的集合

存储过程就是有业务逻辑和流程的集合

可以在存储过程中创建表，更新数据、删除等等

使用场景:

- 通过把处理封装在容易使用的单元中，简化复杂的操作
- 保证数据的一致性
- 简化对变动的管理

触发器

提供给程序员和数据分析员来保证数据完整性的一种方法，他是与表事件相关的特殊的存储过程

使用场景:

- 通过数据库中的相关表实现级更改
- 实时监控某张表的某个字段的更改而需要做出相应的处理
- 某些业务编号的生成
- 滥用会造成数据库以及应用程序的维护困难

MySQL索引

简单描述Mysql中索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响？

Mysql索引的基础和类型：

	索引类似于数据的目录，想要找到一本书的某个特定的主题，需要先查找书的目录，定位对应的页码，存储引擎使用类似的方式进行数据查询，先去索引中找到对应的值，然后根据匹配的索引找到对应的数据行 

索引对性能的影响:

- 大大减小服务器需要扫描到数据量
- 帮助服务器避免排序和临时表
- 将随机I/O变为顺序I/O
- 大大提高查询速度，降低些的速度，占用磁盘

索引的使用场景

- 对于非常小的表，大部分情况下全表扫描效率更高
- 中到大型表，索引非常有效
- 特大型表，建立和使用索引的代价会随之增长，可以使用分区技术来解决

索引的类型

- 普通索引：基本的索引，没有任何的约束限制
- 唯一索引：与普通索引类型，但是具有唯一性约束
- 主键索引：特殊的唯一索引，不允许有空置
- 组合索引：将多个列组合在一起创建索引，可以覆盖多个列
- 外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作
- 全文索引：Mysql自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索

主键索引和唯一索引的区别：

- 一个表只能有一个主键索引，可以有多个唯一索引
- 主键索引一定是唯一索引，唯一索引不是主键索引
- 主键可以与外键构成参照完整的约束防止数据不一致，唯一索引不可以

Mysql索引的创建原则:

- 最适合索引的列是出现在where子句的列，或者链接子句中的列，尾部是在select关键字后的列
- 索引列的技术越大，效果越好
- 对字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间
- 根据情况创建复合索引，复合索引可以提高查询效率
- 避免创建过多的索引，会占用额外的磁盘空间，降低写操作的效率
- 主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用

Mysql索引的注意事项:

- 复合索引遵循前缀原则 key(a,b,c) where a= 1 and b = 2 and c = 3 where a= 1 and b = 2 where a = 1 where b = 2 and c = 3
- like查询，%不能在前，可以使用全文检索 where name like "%wang%" 索引不起作用
- column is null 可以使用索引
- 如果mysql估计使用索引的时间比全表扫描要慢，会自动放弃索引
- 如果or前的条件的列有索引，后面的没有，索引都不会被用到
- 列类型是字符串时，一定要加引号，否则索引会失效

Mysql的SQL语句编写考点

问题：有A(id,sex,par,c1,c2),B(id,age,c1,c2)两张表，其中A.id与B.id关联，现在要求写出一条SQL，将B中age>50的记录的c1,c2更新到A表统一记录中的c1,c2字段中

关联更新:

两种方式：

UPDATE A,B SET A.C1 = B.C1,A.C2 = B.C2 WHERE A.ID= B.ID

UPDATE A INNER JOIN B ON A.ID = B.ID SET A.C1 = B.C1,A.C2 = B.C2

答案：

update A,B set A.c1 = B.c1,A.c2 = B.c2 where A.id = B.id and B.age > 50;

update A inner join B on A.id = B.id SET A.c1 = B.c1,A.c2 = B.c2 where B.age > 50

六种关联查询：

- 交叉连接 cross join

select * from A,B,C

select * from A cross join B cross join C

没有任何的关联条件，结果是笛卡尔积，意义不大

- 内连接 inner join

select * from A,B where A.id = B.id

select * from A inner join B on A.id = B.id

多表中同事符合某种条件记录的集合，分为三类：

等值连接: ON A.id = B.id

不等值连接：ON A.id > B.id

自连接：select * from A T1 inner join A T2 ON T1.id=T2.pid

INNER JOIN 可以缩写成 JOIN

- 外连接

左外连接：LEFT OUTER JOIN 以左表位主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写为LEFT JOIN

右外连接：RIGHT OUTER JOIN 简写为 right join

- 联合查询

select * from A UNION select * from B UNION ...

就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的就是联合查询的列数要相等，相同的记录会合并

如果使用UNION ALL，不会合并重复行

- 全连接 Mysql 不支持全连接

可以使用left join和union和right join 联合使用

select * from A left join B on A.id = B.id union select * from A right join B on A.id = B.id

- 嵌套查询

用一条sql的结果作为另外一条sql语句的条件，效率不好把控,不建议使用

select * from A where id in (select id from B)

Mysql查询优化

项目中优化sql语句执行效率的方法，从哪些方面，sql语句性能如何分析？

- 查找分析查询速度慢的原因
- 优化查询过程中的数据访问
- 优化长难的查询语句
- 优化特定类型的查询语句

分析SQL查询慢的方法:

- 记录慢查询日志

分析查询日志，不要直接打开慢查询日志进行分析，这样比较浪费时间和精力，可以使用pt-query-digest工具进行分析

- 使用show profile

set profiling = 1 开启，服务器上执行的所有语句会检测消耗的时间，存到临时表中

show profiles;//查看临时表

show profiles for query QUERY ID //查看某一条记录的具体时间分配

- show status

show status 会返回一些计数器，show global status 查看服务器级别的所有计数 有时候根据这些计数，可以猜出哪些操作代价较高或者消耗时间较多

- show processlist

观察是否有大量的线程处于不正常的状态或者特使

- explain

分析单条SQL语句，也可以使用desc 来达到一样的效果 desc select * from a

优化查询过程中的数据访问

- 访问数据太多当值查询性能下降
- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或者列
- 确认Mysql服务器是否在分析大量不必要的数据行

避免使用如下SQL:

- 查询不需要的记录，使用limit解决
- 多表关联返回全部列，指定A.id,A.name
- 总是取出全部列，select * 会让优化器完成索引覆盖扫描
- 重复查询相同的数据使用缓存

是否在扫描额外的记录：

使用explain进行分析，如果发现查询需要扫描大量的数据但是只返回少数的行，可以通过以下技巧去优化： 使用索引覆盖扫描，把所有的列都放在索引中，这样索引不需要回标获取对应行就可以返回结果

修改表数据库和表的结构，修改数据表的范式

重写sql，让优化器可以以更优的方式执行

优化长难的查询语句:

mysql 内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢的多 使用尽可能少的查询十号的，但是有的时候将一个大的查询分为几个小的查询也是有必要的

- 切分查询

将一个大的查询分为多个小的相同的查询，比如一次性删除1000万的数据要比一次删除1万，暂停一会儿的方案跟那个价损耗服务器的开销

- 分解关联查询

可以将一条关联语句分解成多条sql来执行

让缓存的效率更高

执行单个查询可以减少锁的竞争

在应用层做关联可以更容易对数据库进行拆分

优化特定类型的查询语句:

- 优化count()查询

count()中的 会忽略所有的列，直接统计所有的列数，因此不要使用count(列名)

myisam中，没有任何where条件的count(*)非常快

当有where条件时，myisam的count统计不一定比其他表引擎快

可以使用explain查询近似值，用近似值替代count(*)

增加汇总表

使用缓存

- 优化关联查询

确定on或者using自居的列上有没有索引

确保group by 和order by 中只有一个表的列，这样才有可能使用索引

- 优化子查询

用关联查询替代

- 优化group by和distinct

这两种查询均可以使用所索引来优化，是最有效的优化方法

关联查询中，使用标识列进行分组的效率会更高

如果不需要order by，进行group by时使用 order by null ,mysql不会再进行文件排序

with rollup超级聚合

- 优化limit分页

limit偏移量大的时候，查询效率较低

可以记录上次查询的最大ID,下次查询时直接根据该ID来查询

- 优化union查询

union all 的效率高于union，去重放到应用层去解决

首先说明如何定位低效sql

根据sql语句可能低效的原因做排查，从索引着手，考虑数据访问的问题，长难句的问题，特定类型优化的问题

Mysql高可扩展和高可用

简述mysql分表操作和分区的工作原理，分别说说分区和分表的使用场景和各自的优缺点

分区表的原理

对用户而言，分区表是一个独立的逻辑表，但是底层Mysql将其分层了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件

创建表的时候使用partition by 子句定义每个enquiry存放的数据，执行查询的时候，优化器会根据分区定义过滤哪些没有我们需要数据的分区，这样查询只需要查询所需数据在的分区既可

主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据放在一起，而且如果想一次性删除整个去的数据也很方便

适用场景：

- 表非常大，无法全部存在内存，或者旨在表的最后有热点数据，其他都是历史数据
- 分区表的数据更易维护，可以对独立的分区进行独立的操作
- 分区表的数据可以分布在不同的及其上，从而高效利用资源
- 可以使用分区避免某些特殊瓶颈
- 可以备份和恢复独立的分区

限制：

- 一个表中只能有1024个分区
- 5.1版本中，分区表表达式必须是证书，5.5可以使用列分区
- 无法使用外键
- 需要对现有表的结构进行修改
- 所有分去都必须使用相同的存储引擎
- 分区字段中如果有主键和唯一索引列，那么主键列和唯一列都必须包含进来
- 分区函数中可以使用的函数和表达式有一定的限制
- 某些存储引擎不支持分区
- 对于myisam分区表不能使用load index to cache
- 对于myisam使用分区表时需要打开更多的文件描述符

分库分表的原理

通过一些hash算法或者工具实现将一张数据垂直或者水平进行物理切分

使用场景：

- 单表记录的数据达到百万或者千万
- 可以解决表锁的问题

分表方式:

- 水平分割

表很大，分割后可以降低在查询时需要读取的数据和索引的页数，同时也降低了索引的层数，提高查询速度

使用场景:表中的数据本身就有独立性，例如表中分别记录各个地区的数据或者不同时期的数据，也别是有数据常用，有些不常用

需要把数据存放在多个介质上

缺点：

- 给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需要unoin操作
- 在许多数据库应用中，这种负责性会超过它带来的有点，查询时会增加读取一个索引层的磁盘次数

垂直分表：

把主键和列放在不同的表中

使用场景：

- 一个表中某些列常用，有些不常用
- 可以使数据量变小，一个数据页能存储更多的数据，查询时减少I/O次数

缺点：

管理冗余列，查询所有的数据需要join操作

整体缺点：有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，不易于扩展

对于应用层来说，逻辑算法会增加开发成本

Mysql复制原理和负载均衡

在主库上把数据更改记录到二进制日志

从库将主库的日志复制到自己的中继日志中

从库读取中继日志中的事件，将其放在自己的库中执行

解决的问题：

- 数据分布：随意停止或者开始复制，并在不同地理位置分布数据备份
- 负载均衡：降低单个服务器的压力
- 高可用和故障切换：帮助应用程序避免单点失败
- 升级测试：可以使用更高版的Mysql作为从库

设定网站的用户数据量在千万级，但是活跃用户的数据量只有1%,如何通过优化数据库提高用户的访问速度？

Mysql安全性考点

SQL语句应该考虑哪些安全性问题

SQL查询的安全方案

- 使用预处理语句防SQL注入
- 写入数据库的数据要进行特殊字符的转义
- 查询错误信息不要返回给用户，将错误记录到日志

Mysql其他安全设置

- 定期做数据备份
- 不给查询用户root权限，合理分配权限
- 关闭远程访问数据库权限
- 修改root口令
- 删除多余用户
- 修改root用户名称
- 限制一般用户浏览其他库
- 限制用户对数据文件的访问权限

PHP如何解决网站大流量与高并发的问题

高并发

高并发的相关概念

在某个时间点，有多少个访问量

如果一个系统的日PV在千万以上，有可能是一个高并发的系统

QPS: 每秒钟请求或者查询的数量，在互联网领域，指每秒相应请求数(指HTTP请求)

吞吐量: 单位时间处理的请求数量

响应时间: 从请求发出到收到相应花费的时间

PV: 综合浏览量 page view 页面浏览量或者点击量，一个访客在24小时之内的浏览量或者点击量

UV: 独立访客unique visitor，一定时间范围内相同访客多次访问网站，只计算一独立个访客

带宽: 计算带宽大小需关注两个指标，峰值流量和页面平均大小

日网站带宽 = PV/统计时间(s)* 平均页面大小(k) * 8



峰值一般是平均值的倍数，根据实际情况来定

QPS不等于并发连接数量

QPS是每秒HTTP的请求数量，并发连接数量是系统同事处理的请求数量

峰值每秒请求数(QPS) = (总PV数 * 80%) / (6小时秒数* 20%)

代表80%的访问量集中在20%的时间（28定律）



压力测试:**

- 压力测试
  常用的性能测试工具 ab（apache benchmark）

模拟并发请求100次，总共请求5000次

    ab -c 100 -n 5000 http://**.com
    
    //-c 并发数
    //-n 请求数量

注意事项: 测试机器与被测试机器分开 | 不要对线上服务做压力测试 | 观察测试功工具ab在机器以及被测试的前端机的CPU、网络等不超过75%

- QPS达到50：不需要优化
- QPS达到100： 假设关系型数据库的每次请求在0.01s完成，假设单个页面只有1个SQL,那么100QPS以为这1秒钟完成100次请求，但是此时我们并不能保证数据库查询能完成100次

方案:数据库缓存层，数据库的负载均衡

- QPS达到800:

假设我们使用百兆带宽，以为这网站出口的实际宽带是8M左右

假设每个页面只有10k，在这个并发下，百兆贷款已经吃完

方案: CDN加速，负载均衡

- QPS达到1000:

假设使用mem缓存数据，每个页面对mem的请求数远大于直接对db的请求

mem的悲观并发数在2w左右，但是有可能在之间内网宽带已经吃光，表现不稳定

方案: 静态HTML缓存

- QPS达到2000:

这个级别下，文件系统访问锁都成为了灾难

方案: 做业务分离，分布式存储

- 测试能承受的最大并发
- 测试最大承受的QPS值

高并发解决方案案例

- 流量优化
- 防盗链处理
- 前端优化：减少http请求（合并css,js,图片）、添加异步请求、启用浏览器缓存和文件压缩、CDN加速、建立独立图片服务器
- 服务端优化：页面静态化、并发处理
- 数据库优化：数据库缓存(mem,redis),分库分表、分区操作、读写分离、负载均衡
- Web服务器优化：负载均衡

Web资源防盗链

盗链概念: 盗链是指在自己的页面上展示一些并不在自己服务器上的内容

常见的小站盗用大战的图片、音乐、视频、软件资源

通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器

防盗链的概念：

防止别人通过一些技术手段盗用自己站点的资源，让资源在别人的站点上无法访问

可以大大减轻服务器以及带宽压力

工作原理: 通过Referer或者签名，网站可以检测目标网页访问的来源网页

- Referer（有漏洞，可伪装）

nginx 模块，ngx_http_referer_module用来阻挡来源非法的域名请求

Nginx指令valid_referers,全局变量$invalid_referer

valid_referers none|blocked|server_names|string...

none 代表为空时

blocked 代表来源头部不为空，但是里面的值被防火墙删除

server_names 代表信任的地址

    location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$
    {
        valid_referers none blocked immoc.com *.imooc.com
        
        #如果有不允许的访问，$invalid_referer 为1 ，重定向到错误页面
        if($invalid_referer) {
            #return 403
            rewrite ^/ http://www.imooc.com/403.jpg
        }
        
    }

- 加密签名。使用第三方模块HttpAccessKeyModule实现Nginx防盗链

    accesskey on|off 模块开关
    
    accesskey_hashmethod md5 | sha-1签名加密方式
    
    accesskey_arg GET参数名称呢
    
    accesskey_signature加密规则

    location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$
    {
        accesskey on;
        #加密方式
        accesskey_hashmethod md5;
        #获取参数的键
        accesskey_arg sign;
        #签名规则
        accesskey_signatur 'jason$remoe_addr';
    }

    <?php
    
    //md5(jason.ip)
    //PHP中的加密规则
    $sign = md5('jason'.$_SERVER['REMOTE_ADDR']);
    
    echo "<img src = './logo.img?sign='.$sign.'>"

减少HTTP的请求

性能黄金法则：只有10%-20%的最终用户响应时间花在接受请求的HTML上，剩下的80%-90%时间花在HTML文档所引用的js,css等组件上

如何改善：改善相应时间的最简单的途径就是减少组件的数量，并由此减少HTTP的请求量

HTTP请求连接产生的开销

域名解析--TCP连接--发送请求--等待--下载资源--解析时间

疑问？

DNS缓存、Keep-Alive会不会消除影响

查找DNS缓存也需要时间，多个缓存就要查找多次有可能缓存会被清楚

HTTP1.1协议规定请求只能串行发送，也就是100个请求必须依次逐个发送，前面的一个请求完成才能开始下个请求

减少HTTP请求的方式

- 图片地图：图片地图允许你在一个图片上关联多个URL,目标URL的选择取决于用户单击了图片上的那个位置

    <img usemap="#map1" src="/image/image.git=f">
    <map name="map1">
         <area shape='rect' coords='0,0,31,31' href='javascipt:alert('Home')' title='Home'>
         <area shape='rect' coords='36,0,66,31' href='javascipt:alert('Cart')' title='Cart'>
         ...
         ...
    <map>

- CSS Sprites

CSS Sprites中文翻译CSS精灵，通过使用合并图片，通过指定的cssbackground-image 和backgroud-position来显示元素

- 合并脚本和样式表

使用外部的js和css文件引用的方式，因为这样比直接写在页面中性能要更好一点

把多个脚本合并成一个脚本，把多个css合并成一个css

- 图片使用Base64编码减少页面请求数

采用base64的编码方式将图片直接嵌入到网页中，而不是从外部载入

    <img src='data:image/gif;base64,/9j/4AAQSkZJ....'>

浏览器缓存和数据压缩

高并发下只能通过提升服务器负责解决吗？

缓存只能做数据库缓存吗？

相关概念

HTTP缓存机制

前端代码和资源的压缩

缓存分类

HTTP缓存模型中，如果请求成功会有三种情况

- 200 from memory cache:直接从本地缓存中获取相应，最快速，最省流量，因为根本没有向服务器发送请求 本地缓存

相关Header

Pragma:HTTP1.0时代的遗留产物，该字段被设置为no-cache时没，会告知浏览器禁用本地缓存，每次都向服务器发送请求

Expires:HTTP1.0时代用来启动本地缓存的字段，expires值对应一个形如Thu，31 Dec 2037 23：55：55 GMT的格林威治时间，告诉浏览器缓存实现的时刻，如果时间还没到，标明缓存有效，无需发送请求，但是Expire是Nginx发送的，如果浏览器时间不准确，会造成很大的影响

Cache-Control:HTTP1.1针对Expires时间不一致的解决方案，运用Cache-Control告知浏览器缓存国企的时间间隔而不是时刻，即使具体时间不一致，也不影响缓存的管理 no-store:禁止浏览器缓存响应 no-cache：不允许直接使用本地缓存，先发起请求和服务器协商 max-age=delta-seconds:告知浏览器该相应本地缓存有效的最长期限，以秒为单位

优先级 Pragma > Cache-Control > Expires

- 304 Not Modified:协商缓存，浏览器在本地没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端数据没有改变，浏览器从本地缓存相应，返回304

相关Header

Last-Modified:通知浏览器资源的最后修改时间

If-Modified-Since：得到资源的最后修改时间后，会将这个信息通过If-Modified-Since提交到服务器做检查，如果没有修改，返回304状态码

ETag:HTTP1.1推出，文件的指纹标识符，如果文件内容修改，指纹会改变

If-None-Math:本地缓存失效失败，会携带此值去请求服务端，服务端判断该资源是否改变，如果没有改变，直接使用本地缓存，返回304

- 200 OK 以上两种缓存失败，服务器返回完整相应数据，没有用到缓存，相对最慢

缓存策略的选择

适合本地缓存的内容

- 不变的图像，如logo，图标
- js,css静态文件
- 下载的文件

适合使用协商缓存

- HTML文件
- 经常替换的图片
- 经常修改的js,css文件
- js,css文件的加载可以加入文件的签名来拒绝签名 index.css?签名|index.签名.js

不建议缓存的内容

- 用户隐私等敏感数据
- 经常改变的api数据接口

Nginx配置缓存策略

    <?php
    //获取响应头的If-Modified-Since参数
    $since = $_SERVER['HTTP_IF_MODOFIED_SINCE'];
    //设置生存时间
    $lifttime = 3600;
    //如果没有过期
    if (strtotime($since)+ $lifetime > time()) 
    {
        header('HTTP/1.1 304 Not Modified');
        exit;
    }
    header('Last-Modified:' . gmdate('D,d M Y H:i:s',time()).'GMT')

本地缓存配置

    add_header指令：添加状态码为2xx和3xx的相应投信息
    add_header name value [always]
    可以设置Pragma/Expire/Cache-Control，可以继承
    expires指令:通知浏览器过期时间expires time;为负值时表示Cache-Control：no-cache

    # nginx.conf
    location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$
    {
        valid_referers none blocked immoc.com *.imooc.com
        
        #如果有不允许的访问，$invalid_referer 为1 ，重定向到错误页面
        if($invalid_referer) {
            #return 403
            rewrite ^/ http://www.imooc.com/403.jpg
        }
        # 缓存30天
        expires 30d;
        # 关闭etag
        etag off;
         # 添加cache-control
        add_header
        cache-control max-age=3600
    }

前端代码和资源压缩

可以让资源文件更小

压缩方式：js,css,image,html代码压缩、 Gzip压缩

js压缩的原理一般是去掉多余的空格和回车，替换长变量名，简化写法

常用的压缩工具：UglifyJS、YUI Compressor 、Closure Compiler

图片压缩：

压缩工具：tinypng、JpegMini，ImageOptim

Gzip压缩： 配置Nginx

    gzip on|off
    gzip_buffers 32k
    gzip_disable
    gzip_min_length 200
    ...
    ...

数据库缓存

相关概念

- 什么是数据库缓存？
- 为什么使用缓存
- 使用MySQL查询缓存
- 使用Memcache缓存
- 使用Redis缓存

什么是数据库缓存

Mysql等一些常见的关系型数据库的数据都存储在磁盘中，在高并发场景下，业务应用对mysql产生的增删改查的操作造成巨大的I/O开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生

数据库缓存极大的解决数据库服务器的压力

提高应用数据的响应速度

常见的缓存形式：内存缓存、文件缓存，为了避免I/O开销，推荐使用内存缓存

为什么使用缓存

缓存数据时为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大程度的降低对数据库服务器的访问压力

用户请求-->数据查询-->连接数据库服务器并查询数据-->将数据缓存起来(HTML,内存，JSON,序列化数据)-->显示给客户端

用户再次请求或者新用户访问-->数据查询-->直接从缓存中获取数据-->显示给客户端

缓存方式的选择

缓存场景的选择

缓存数据的实时性

缓存数据的稳定性

MySQL查询缓存

启用mysql查询缓存：

    query_cache_type
    #查询缓存类型有0，1，2三个取值。0表示不使用缓存，1表示始终使用查询缓存，2表示按需使用查询缓存
    
    query_cache_type = 1
    #此时也可以关闭查询缓存
    select sql_no_cache * from table where condition;
    
    query_cache_type = 2
    # 按需查询缓存
    select sql_cache * from table where condition
    
    query_cache_size
    #默认情况下的query_cache_size为0，表示为查询缓存预留的内存位0，则无法使用查询缓存
    
    set global query_cache_size = 133443344;
    # 设置query_cache_size的大小

查询缓存可以看做是sql文本和查询结构的映射

第二次查询的sql和第一次查询的sql必须完全相同才会使用缓存

show status like 'Qcache_hits' 查看命中次数

表的结构或者数据发生改变时，查询缓存中的数据不再有效

清理缓存

flush query cache;清理查询缓存内存碎片

reset qyery cache;从查询缓存中移除所有查询

flush tables;关闭所有打开的表，同时该操作将会清空表缓存的内容

使用Memcache缓存查询数据

memcache 是一套分布式的高速缓存系统，由LiveJournal的Bard Fitzpatrict开发，但目前被许多网站使用以提升网站的访问速度，尤其是对一些大型的、需要频繁访问数据库的网站访问速度提升效果十分明显

- 工作原理

memcache 是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像，视频，文件以及数据库检索的结构等。简单的说就是将数据调用到内存，然后从内存读取，从而大大提高读取速度。

- 工作流程

先检查客户端的请求数据是否在mem中，有的话直接返回，不在的话就去查库，把数据库中的数据返回给客户端，同时缓存到mem中

- 方法

获取： get(key)

设置：set（key）

删除：delete(key)

Redis缓存查询数据

- 与memcache的区别

性能差别不大

Redis在2.0版本后增加了自己的VM特性，突破了物理内存的限制，mem可以修改最大可用内存，采用LRU算法

Redis依赖客户端实现分布式读写，mem本身没有数据冗余机制，Redis支持(快照，AOF)，依赖快照进行持久化，aof增强了可靠性的同时对性能有所影响

mem不支持持久化，在并发情境下用cas保证一致性，redis事务支持较弱，Redis支持多种类的数据类型

Redis用于数据量小的高性能的操作和运算上，mem用于在动态系统中减少数据库负载，提升性能，适合做缓存，提高性能

缓存其他数据

- Session

将session存入到数据库来说是一种逆天的行为，可以存储到mem和redis中session_set_save_handler来修改存储地址

MySQL数据库层的优化

相关概念

- 优化方向
- 优化方案

优化方向

- 数据表结构设计的优化
- 数据表数据类型的优化

字段使用什么样的数据类型更合适

    tinyint（0-255）、smallint、bigint（存储上千万的数字）#考虑空间的问题，考虑范围的问题，按需取
    char、varchar #考虑字符串长度是否固定
    enum #特定、固定的分类可以使用enum存储，效率更快
    IP地址的存储#ip2long将ip转换成长整型，long2ip

- 存储引擎的优化

建立合适的索引，在什么时候效率最好？

索引的创立原则： 不是越多越好，在合适的字段上创建合适的索引

复合索引的前缀的原则,like 查询%的问题，全表扫描优化，or条件索引使用情况，字符串类型索引失效问题

- 数据库服务器架构的优化

分区操作

七层负载均衡的实现

基于URL等应用层信息的负载均衡

Nginx的proxy是一个很强大的功能，实现了7层负载均衡

功能强大、性能卓越，运行稳定

配置简单灵活

能自动提出工作不正常的后端服务器

上传文件使用异步模式

支持多种分配策略，可以分配权重

Nginx负载均衡有内置策略，扩展策略两种方式

内置策略

- IP Hash

流程和轮询很相似，是一种变相的轮询算法

- 加权轮询

首先将请求分给高权重的机器，知道该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器

当所有后端机器都down掉时，Nginx会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在timeout的状态

扩展策略

- fair 策略

根据后端服务器的响应时间判断负载情况，从中选择出负载最轻的机器进行分流

- 通用hash

以nginx内置的变量为key进行hash

- 一致性hash

支持mem

Nginx配置方案

    #nginx.conf
    http{
        upstream cluster{
            server srv1;
            server srv2;
            server srv3;
        }
        server {
            listen 80;
            location / {
                proxy_pass http://cluster
            }
        }
    }

四层负载均衡实现

通过报文中的目标和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器

LVS实现服务器集群负载均衡有三种方式NAT,DR,TUN

动态语言的并发处理

相关概念

- 什么是进程、线程、协程
- 什么是多进程、多线程
- 同步阻塞模型
- 异步非阻塞模型
- php并发编程实践

什么是进程、线程、协程

进程

进程是一个执行中的程序

进程的三态模型：多道程序系统中，进程在处理器上交替运行，状态不断的发生变化

运行、就绪、阻塞

运行：当一个进程在处理机上运行时，则称该进程处于运行状态

就绪：当一个进程获得了除处理机以为的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态

阻塞:也成等待或睡眠状态，一个进程正在等待某一时间发生而暂停停止运行，这时即使把处理机分配给进程也无法运行

进程的五态模型 :

对于一个世纪的系统，进程的状态以及转换更为复杂

新建态：对应于进程刚刚被创建时没有被提交的状态，并且等待系统完成创建进程的所有必要信息

终止态:进程已经结束运行，回收进行控制块以外的其他资源，并让其他进程从进程控制块中收集有关信息

活跃就绪:进程在主存并且可被调度的状态

静止就绪:进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程或者是挂起就绪进程具有更高的优先级，系统将把挂起就绪状态进程调回主存并转换为活跃就绪

活跃阻塞：指进程在主存，一旦等待的事件产生便进入活跃就绪状态

静止阻塞：进程对换到辅存时的阻塞状态，一旦等待事件产生便进入静止就绪状态

线程

由于用户的并发请求，为每一个请求都创建一个进程显然是行不通的，从系统资源开销方面或者是响应用户请求的效率方面来看，因此操作系统中线程的概念便被引进了

线程，有时候被称为轻量级进程

线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但是她可以同属一个进程的其他线程共享进程所拥有的全部资源

一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行

线程是程序中一个单一的顺序控制流程。进程内一个相对独立的可以调度的执行单元，是系统独立调度和分配CPU的基本单位，指运行程序的调度单位

在单个程序中同时运行多个线程完成不同的工作，称为多线程

每一个程序至少有一个线程，如果只有一个线程，那就是程序本身了

线程的三种状态：就绪状态，运行状态，阻塞状态

协程

协程是一种用户台的轻量级线程，协程的调度完全由用户控制。

线程与进程的区别

- 线程是进程内的一个执行单元，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间
- 进程是资源分配和拥有的但愿，同一个进程内的线程共享进程的资源
- 线程是处理器调度的基本单位，但进程不是
- 两者均可并发执行
- 每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须已存在应用程序中，由应用程序提供多个线程执行控制

线程和协程的区别

- 一个线程可以有多个协程，一个进程也可以单独拥有多个协程
- 线程进程都是同步机制，而协程则是异步
- 协程可以保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

什么是多进程、多线程

多进程：同一时间里，同一个计算机系统中如果允许两个或者两个以上的进程处于运行状态，这就是多进程

多开一个进程，多分配一份资源，进程间通讯不方便

多线程：线程就是吧一个进程分诶很多片，每一个片都可以是一个独立的流程

例子

单进程单线程：一个人在一个桌子上吃菜

单进程多线程：多个人在同一个桌子上吃采

多进程单线程：多个人每个人在自己的桌子上吃菜

同步阻塞

多进程：最早的服务器端的程序都是通过多进程、多线程来解决并发的IO问题

一个请求创建一个进程，然后子进程进入循环同步阻塞的与客户端连接并且进行交互，手法处理数据

多线程：线程中可以直接向客户端连接发送数据

步骤：

创建一个socket

进入while循环，阻塞在进程accept操作上，等待客户端连接进入

主进程在多进程模式下通过fork创建子进程

多线程模型下可以创建子线程

子进程/线程创建成功后进入while循环，阻塞在recv调用上，等待客户端向服务器发送数据

收到数据后服务器程序进程处理然后使用send向客户端发送响应

当客户端连接关闭时，子进程/子线程退出并销毁所有资源。主进程/线程会回收掉此子进程/线程

缺点：严重依赖进程来解决并发问题，会造成严重消耗

异步非阻塞

现在各种高并发异步IO的服务器程序都是基于epoll实现的

IO复用异步非阻塞程序使用景点的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据首发，只是可以监听一个socket句柄的时间变化

Add:添加一个socket 到 Reactor

Set：修改socket对应的时间，如可读可写

Del:从Reactor中移除,不再监听事件

Callback:事件发生后回调指定的函数

Nginx:使用的就是多线程的Reactor

Swoole:使用的是多线程的Reactor和多进程的Worker

PHP并发编程实践

- php的Swoole扩展

php的异步、并行、高性能网络通信引擎，使用纯C语言编写，提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步Mysql，异步Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询

除了异步IO支持之外，Swoole为PHP多进程的模式设计了多个并发数据结构和IPC通信机制，可以大大简化多进程并发编程的工作

Swoole2.0支持了类似Go语言的协程，可以使用完全同步的代码实现异步程序

- Swoole的异步Mysql实现

    $db = new Swoole\MySQL;
    $server = array('host'=>'','user'=>'','password'=>'','database'=>'');
    
    $db->connect($server,function($db,$result) {
        $db->query('show tables',function(Swoole\MySQL $db,$result) {
            //do some thing;
        });
    });

- 消息队列

场景说明:用户注册后，需要发注册邮件和注册短信

串行方式:将注册信息写入数据库成功后，发送注册邮件，再发送注册短信

并行方式：将注册信息写入数据库成功后，发送注册邮件的同时发送注册短信

消息队列：将注册信息写入数据库成功后，将成功的信息写入队列，此时直接返回成功给用户，写入队列的时间非常短，可以忽略不计，然后异步发送邮件和短信

- 应用解耦

场景说明：用户下凡后，订饭系统需要通知库存系统

加入库存系统无法访问，则订饭减库存将失败，从而导致订单失败，订单系统与库存系统解耦

引用队列，用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户下单成功

订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存处理

- 流量削峰

应用场景：秒杀活动，流量瞬间激增，服务器压力大

用户发起请求，服务器接收后，先写入消息队列，加入消息队列长度超过最大值，则直接报错或者提示用户

后续的程序读取消息队列，去处理

控制请求量 缓解高流量

- 日志处理

应用场景：解决大量日志的传输

日志采集程序将程序写入消息队列，然后通过日志处理程序的订阅消费日志

- 消息通讯

应用场景：聊天室

多个客户端订阅同一个主题，进行消息发布和接收

- 常见消息队列产品

Kafka、ActiveMQ、ZeroMQ、RabbitMQ、Redis等

- 接口的并发请求

curl_multi_init

算法

算法的概念

一个问题可以有多种算法，每种算法都有不同的效率 算法评定从时间复杂度和空间复杂度计算

时间复杂度和空间复杂度

时间复杂度： 执行算法所需要的计算工作量，一般来说，计算机算法是问题规模N的函数f(n),算法的时间复杂度也因此记作T（n）= O(f(n))

计算方式：

- 得出算法的计算次数

    #1+2+3+4+...+n
    for(i=1;i<=n; i++){
        $sum += i;
    }
    #总共循环了n次，所以时间复杂度为O(n)

- 用常数1来取代所有时间中的加法常数
- 在修改后的运行次数函数中，只保留最高阶
- 如果最高阶存在且不是1，则去除与这个数相乘的常数

举例

    function test($n) {
        echo $n;
        echo $n;
        echo $n;
    }
    #计算3次，O(3)--记作->O(1)
    
    for($i = 1; $i<= $n;$i++) {
        for ($j = 1;$j<=$n;$j++) {
            $sum += $j;
        }
    }
    
    #n * n 次 时间复杂度为O(n^2)
    
    for($i = 1; $i<= $n;$i++) {
        for ($j = 1;$j<=$n;$j++) {
            $sum += $j;
        }
    }
    for () {
        n次
    }
    echo $a + b 
    #n^2 + n + 1 --->忽略 --> O(n^2)
    
    while($n>=1) {
        $n = $n/2;
    }
    #n执行次数
    
    n/(2^m) = 1
    #m = log2n,所以时间复杂度O(log2n)

效率排名：O(1)>O(log2n)>O(n)>O(nlog2n)>O(n^2) > O(n^3) > O(2^n) > O(n!) > O(n^n)

最坏的情况：最坏情况时的运行时间，一种保证，如果没有特别说明，说明时间复杂度为最坏的时间复杂度

空间复杂度

S(n) = O(f(n)),算法需要消耗的内存空间

包括程序代码、输入数据、辅助变量所占用的空间

计算方式：

有时用空间换取时间 冒泡排序的元素交换，空间复杂度就是O(1)

常见排序算法

冒泡排序、直接排序、希尔、选择、快速、堆、归并排序

- 冒泡排序

原理：两两相邻的数进行比较，如果反序就交换，否则不交换

时间复杂度：最坏O(n^2),空间复杂度O(1)

    #m冒泡排序
    1,3,2,4,6,5
    1,3,2,4,6,5
    1,2,3,4,6,5
    1,2,3,4,6,5
    1,2,3,4,5,6
    
    for ($i=0;$c = count($arr);$i<$c;$i++){
        for($j=0;$j<$c;$j++) {
            $arr[$j] = $arr[$j+1];
            $temp = $arr[$j];
            if ($arr[$j] > $arr[$j+1]) {
              $arr[$j+1] = $temp;
            }
        }
    }

- 直接插入排序

原理：每次从无序表中取出一个元素，把它插入到有序表的合适的位置，使有序表依然有序

时间复杂度O(n^2),空间复杂度O(1)

- 希尔排序

把待排序的数据很具增量分成几个子序列，对子序列进行插入排序，直到增量为1，直接进行插入排序；增量的排序一般是数组长度的一半，再变为原来增量的一般，知道增量为1

时间复杂度O(n^2)空间复杂度O(1)

- 选择排序

每次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完

时间复杂度 O(n^2),空间复杂度O(1)

- 快速排序

通过一趟排序将要排序的数据分割成独立的两个部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按照此方法对这两个部分数据进行快速排序，整个排序过程可以递归完成

时间复杂度为最差O(n^2)平均O(nlog2n) 空间复杂度为O(n)，平均O(nlog2n)

    function swap(array &$arr,$a,$b){
        $temp = $arr[$a];
        $arr[$a] = $arr[$b];
        $arr[$b] = $temp;
    }
    
    function Partition(array &$arr,$low,$high){
        $pivot = $arr[$low];   //选取子数组第一个元素作为枢轴
        while($low < $high){  //从数组的两端交替向中间扫描
            while($low < $high && $arr[$high] >= $pivot){
                $high --;
            }
            swap($arr,$low,$high);	//终于遇到一个比$pivot小的数，将其放到数组低端
            while($low < $high && $arr[$low] <= $pivot){
                $low ++;
            }
            swap($arr,$low,$high);	//终于遇到一个比$pivot大的数，将其放到数组高端
        }
        return $low;   //返回high也行，毕竟最后low和high都是停留在pivot下标处
    }
    
    function QSort(array &$arr,$low,$high){
        if($low < $high){
            $pivot = Partition($arr,$low,$high);  //将$arr[$low...$high]一分为二，算出枢轴值
            QSort($arr,$low,$pivot - 1);   //对低子表进行递归排序
            QSort($arr,$pivot + 1,$high);  //对高子表进行递归排序
        }
    }
    
    function QuickSort(array &$arr){
        $low = 0;
        $high = count($arr) - 1;
        QSort($arr,$low,$high);
    }

- 堆排序

把待排序的元素按照大小在二叉树位置上排序，排序好的元素要满足：父节点的元素要大于等于子节点；这个过程叫做堆化过程，如果根节点存放的是最大的数，则叫做大跟堆，如果是最小，就叫小根堆，可以把节点拿出来，然后再堆化，循环到最后一个节点

时间复杂度：O(nlog2n) 空间复杂度：O(1)

- 归并排序

将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个有序的子序列，再把有序的子序列合并为整体有序序列

时间复杂度O(nlog2n) 空间复杂度O(n)

    //交换函数
    function swap(array $arr,$a,$b) {
        $temp = $arr[$a];
        $arr[$a] = $arr[$b];
        $arr[$b = $temp];
    }
    //归并算法总函数
    function mergeSort(array $arr) {
        $start = 0;
        $end = count($arr) - 1;
        Msort($arr,$start,$end);
    }
    functin Msort(array &$arr,$start,$end) {
        //当子序列长度为1时，$start == $end,不再分组
        if ($start < $end) {
            $mid = floor(($start + $end) / 2);//将 $arr 平分为 $arr[$start - $mid] 和 $arr[$mid+1 - $end]
            MSort($arr,$start,$mid);//将 $arr[$start - $mid] 归并为有序的$arr[$start - $mid]
            MSort($arr,$mid + 1,$end);//将 $arr[$mid+1 - $end] 归并为有序的 $arr[$mid+1 - $end]
            Merge($arr,$start,$mid,$end); //将$arr[$start - $mid]部分和$arr[$mid+1 - $end]部分合并起来成为有序的$arr[$start - $end]
        
        }
    }
    //归并操作
    function Merge(array &$arr,$start,$mid,$end){
        $i = $start;
        $j=$mid + 1;
        $k = $start;
        $temparr = array();
    
        while($i!=$mid+1 && $j!=$end+1)
        {
           if($arr[$i] >= $arr[$j]){
               $temparr[$k++] = $arr[$j++];
           }
           else{
               $temparr[$k++] = $arr[$i++];
           }
        }
    
        //将第一个子序列的剩余部分添加到已经排好序的 $temparr 数组中
        while($i != $mid+1){
            $temparr[$k++] = $arr[$i++];
        }
        //将第二个子序列的剩余部分添加到已经排好序的 $temparr 数组中
        while($j != $end+1){
            $temparr[$k++] = $arr[$j++];
        }
        for($i=$start; $i<=$end; $i++){
            $arr[$i] = $temparr[$i];
        }
    }

常见查找算法

- 二分查找

从数组的中间元素开始，如果中间元素正好是要查找的元素，搜索结束，如果某一个特定元素大于或者小于中间元素，则在数组大于或者小于中间元素的一半中查找

时间复杂度最差O（log2n）空间复杂度迭代o(1),递归O（nlog2n）

- 顺序查找

按一定的顺序检查数组中的每一个元素，直到找到所要寻找的特定值为止

时间复杂度：O(n) 空间复杂度O(1)

其他算法

1,1,2,3,5,8,13,21,34...第30位是多少？使用伪代码描述其实现方法。 伪代码就是文字描述就可以

    $arr = [1,1];
    for ($i=2;$i<30;$i++) {
        $arr[$i] = $arr[$i-1] + $arr[$i-2];
    }
    var_dump($arr);
